<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Design System</title>
  <!--pretendard 로드-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendardvariable.css" />
  <!-- Roboto Mono -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="designsystem.css" />
</head>
<body>
 <!-- GNB -->
 <nav class="gnb">
    <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="work.html">Work</a></li>
        <li><a href="article.html">Article</a></li>
        <li><a href="https://my.surfit.io/w/125142535" target="_blank">Resume</a></li>
    </ul>
 </nav>
 <aside class="toc">
  <nav class="toc__nav">
    <a href="#sec-summary" class="active">요약</a>
    <a href="#sec-principle">디자인 원칙 수립</a>
    <a href="#sec-designsystem">디자인 시스템 구축 </a>
    <a href="#sec-foundation">파운데이션</a>
    <a href="#sec-version">버전 관리 원칙</a>
    <a href="#sec-component">컴포넌트</a>
    <a href="#sec-result">결과</a>
    <a href="#sec-final">회고</a>
  </nav>
</aside>
  <!-- 그라데이션 영역 -->
 <section class="hero-section">
    <div class="hero-content">
        <h1 class="hero-title">Design System</h1>
        <p class="hero-desc">브랜드 정체성 재정립을 위한 디자인 시스템 구축</p>
    </div>
 </section>
 <section class="summary-black-section"> 
    <div class="content-wrap">
        <div class="summary-title" id="sec-summary">Summary</div>
        <div class="summary-subtitle">Key Responsibilities</div>
        <ul class="summary-list">
            <li><strong>브랜딩 디자인 원칙 수립 :</strong> 제품 아이덴티티에 적합한 디자인 원칙을 정의하여 브랜드의 메시지를 명확히 시각화했어요.</li>
            <li><strong>디자인 시스템 구축 :</strong> 체계적으로 설계·구축하여 제품 전반에서 일관된 사용자 경험을 제공했어요.</li>
        </ul>
        <div class="goal-card">
            <p class="goal-eyebrow">Business Goal</p>
            <h3 class="goal-heading">브랜드 포지셔닝 재정립과 사용자 경험의 일관성 강화</h3>
            <p class="goal-body">굿덕은 다양한 아티스트와 팬을 연결하는 플랫폼이에요. 하지만 기존에는 캐릭터와 강렬한 컬러가 중심이 되면서, <br> 
                브랜드가 특정 톤에 치우쳐 있었어요.  그래서 브랜드를 중립적인 느낌을 줄 수 있게 재정립하고, <br> 동시에 제품 전반의 디자인 경험을 일관되게 만드는 것이 필요했어요.
            </p>
        </div>
        <div class="situation-card">
        <p class="goal-eyebrow">Situation</p>
        <h3 class="goal-heading">기존 캐릭터성(‘더기’)과 강렬한 주황색이 <br> 특정 이미지에 치우쳐 다양한 아티스트를 포용하지 못함.</h3>
        <p class="goal-body">실제 인터뷰에서도 아티스트와의 이미지와 맞지 않는다는 의견이 많았어요. <br> 즉, 브랜드와 사용자 기대가 불일치하고, 서비스의 본질(아티스트와 팬의 관계)이 가려지고 있었어요.
        </p>
        <div class="situation-images">
            <!-- 왼쪽 캐릭터 -->
            <div class="img-box character">
                <img src="src/assets/image/designsystem_duck.png" alt="기존 캐릭터"/>
            </div>
            <!-- 오른쪽 목업 2장 (서로 아래정렬) -->
             <div class="mockups">
                    <div class="img-box phone">
                        <img src="src/assets/image/artistmain_v2.png" alt="굿덕 앱 첫 화면" />
                    </div>
                    <div class="img-box phone">
                        <img src="src/assets/image/designsystem_feed.png" alt="굿덕 앱 피드 화면" />
                    </div>
             </div>
        </div>
        </div>
        <div class="situation-card">
            <p class="goal-eyebrow">Behavior</p>
            <h3 class="goal-heading">새로운 브랜딩 디자인 원칙과 디자인 시스템 구축</h3>
            <p class="goal-body">이를 해결하기 위해 먼저 브랜딩 디자인 원칙을 세우고, 이 원칙을 바탕으로 디자인시스템을 만들었어요.
            </p>
            <div class="impact-metrics">
                <!-- metric 1 -->
                <div class="metric">
                    <div class="metric-label">깔끔한</div>
                    <div class="metric-value"><span class="num">Simple</span> 개선</div>
                </div>
                <!-- metric 2 -->
                <div class="metric">
                    <div class="metric-label">정직한</div>
                    <div class="metric-value"><span class="num">Honest</span></div>
                </div>
                <!-- metric 3 -->
                <div class="metric">
                    <div class="metric-label">공평한</div>
                    <div class="metric-value"><span class="num">Equitable</span></div>
                </div>
            </div>
        </div>
            <div class="goal-card">
            <p class="goal-eyebrow">Impact</p>
            <h3 class="goal-heading">스토리북으로 출시 전 디자인 대응과 <br> 개발자와의 커뮤니케이션 감소</h3>
            <p class="goal-body">- 브랜드적으로는 캐릭터 의존에서 벗어나, <br> 다양한 아티스트와 팬이 어색하지 않게 사용할 수 있는 중립적 브랜드 이미지를 얻었어요. <br> 
                - 운영 측면에서는 디자인·개발 간 커뮤니케이션 비용이 줄고, 유지보수 효율성이 높아졌어요.
            </p>
        </div>
    </div>
 </section>
 <section class="intro-white-section">
    <p class="goal-eyebrow">배경</p>
    <div class="cv-title">왜 브랜딩 및 디자인시스템이 필요했는가</div>
    <div class="cv-lead"><strong>브랜드 이미지와 아티스트·팬이 원하는 분위기가 달랐어요</strong><br>
        인터뷰에서 “일단 오리가 떠오른다”, “약간 너무 귀여운 이미지”, “우리 밴드 이미지와 거리감” 같은 피드백이 반복됐어요.<br> 
        또한 캐릭터(더기)와 강한 주황색 톤이 ‘플랫폼의 정체성’을 과도하게 대표하여, 장르·톤이 다양한 아티스트를 담기에 편향된 인상을 만든 점이에요.<br>
        아티스트·팬의 ‘콘텐츠’가 중심이어야 하는데, 브랜드 요소(캐릭터·주황 톤)가 전면에 나온 탓에 콘텐츠 주목도가 떨어지는 구조였어요.<br>
        결과적으로 “굿덕=귀여움/말랑말랑함”이라는 선입견이 생겨, 다른 톤의 아티스트가 스스로 부적합하다고 느끼는 상황이 되었어요.</div>
    <p class="goal-eyebrow goal-eyebrow--ver2" id="sec-principle">브랜드 디자인 원칙 수립</p>
    <div class="cv-title">브랜드 경험의 일관성을 위해 디자인 원칙부터 정하고 시작했어요.</div>
    <div class="cv-lead">기존 굿덕의 너무 개성이 강한 주황색과 캐릭터 아이덴티티를 버리고, <br> 
        다양한 아티스트와 팬이 어색하지 않게 사용할 수 있는 깔끔하고 정직한 디자인으로 방향성을 잡았어요. <br>
        이 원칙에 어긋나지 않게 디자인 시스템을 만들었어요.
    </div>
    <div class="branding-principle">
        <img src="src/assets/image/designsystem_brending.png" alt="브랜딩 원칙"/>
    </div>
 </section>
 <section class="designsystem-gray-section">
    <div class="content-wrap">
        <p class="goal-eyebrow" id="sec-designsystem">디자인 시스템 구축</p>
        <div class="cv-title">무엇을 해결하기 위해 만들것 인가?</div>
        <p class="goal-eyebrow goal-eyebrow--color">디자인 일관성 확보</p>
        <div class="cv-lead">혼자 만드는 제품이라 하더라도 디자인 변경용이성, 유지보수성, 일관성은 중요해요. <br> 동일한 버튼, 동일한 색상을 어디에서나 일관되게 사용할 수 있어요.</div>
        <p class="goal-eyebrow goal-eyebrow--color">작업 공수 절감</p>
        <div class="cv-lead">스토리북 기반의 디자인 검수 환경이 구축되어, 출시 전 디자이너가 직접 UI를 확인하고 수정을 요청할 수 있어요.</div>
        <p class="goal-eyebrow goal-eyebrow--color">유지보수 편의성</p>
        <div class="cv-lead">여러 화면에서 관리할 UI요소와 속성의 수가 많다면, <br> 어떤 요소를 변경했을 때 제품의 여러 부분에 흩어져있는 요소들을 확실하게 변경해서 확인하는 것이 힘들어요. <br> 디자인 시스템으로 일괄적으로 관리하면 해결 가능해요.</div>
        <p class="goal-eyebrow goal-eyebrow--color">개발 커뮤니케이션 효율화</p>
        <div class="cv-lead">컴포넌트 명명 규칙, 시맨틱 컬러 등 디자이너-개발자간의 언어가 통일되고, <br>세세한 여백 관리 등 레이아웃 등이 명시되어있어 UI 디자인에 소요되는 커뮤니케이션이 감소되고 개발자가 실수할 확률이 줄어들어요.</div>
 </section>
 <section class="foundation-white-section">
    <p class="goal-eyebrow" id="sec-foundation">파운데이션</p>
    <div class="cv-title">시맨틱 컬러가 필요한 이유</div>
    <div class="simantic_image">
        <img src="src/assets/image/designsystem_simantic.png" alt="시맨틱 컬러"/>
    </div>
    <div class="cv-lead">굿덕 전 회사에서 처음 디자인 시스템을 만들었을 때, 시맨틱컬러의 중요성을 몰랐어요. <br> 그래서 만들었지만 제대로 활용하지 못했어요. 활용하지 못하는 채로 디자인을 진행하니, 여러 문제가 있었어요. <br>
        과하게 컬러를 많이 생성해서 제대로된 역할에 쓰이지 못해 뒤죽박죽이 되어 일관성에 문제가 생겼을 때 시맨틱컬러의 중요성을 직접 체감하게 됐어요.</div>
    <p class="goal-eyebrow goal-eyebrow--color">1. 의미 기반으로 색상을 관리할 수 있어 일관성이 유지됨.</p>
    <div class="cv-lead">#FF0000 같은 원색 값을 직접 쓰는 대신, error, success, warning, primary 같은 의미 단위의 토큰으로 정의하면, <br>
        “왜 이 색이 쓰였는가(의도)”에 따라 이해할 수 있어, 단순 색상 코드보다 역할의 의미를 이해하기 쉬워 관리가 용이해져요. <br> 디자이너와 개발자가 같은 용어(error, success)를 공유하므로 커뮤니케이션도 훨씬 명확해져요.</div>
    <p class="goal-eyebrow goal-eyebrow--color">2. 색상 변경 및 확장성</p>
    <div class="cv-lead">브랜드 리뉴얼, 접근성 강화가 필요할 때 시맨틱 레이어만 수정하면 전체 시스템에 반영할 수 있어요. <br> 예를 들어, 브랜드 리뉴얼로 primary 컬러변경이 필요할 때, 시맨틱 컬러 토큰을 쓰면 한번에 변경 가능해요.</div>
    <div class="cv-title cv-title--margin">레이아웃이 필요한 이유</div>
    <div class="cv-lead"><strong>Layout 정의는 디자인 시스템의 "뼈대" 역할을 하며, 일관성, 생산성, 유지보수성, 확장성을 모두 높여줄 수 있어요.</strong></div>
    <div class="layour-img">
        <img src="src/assets/image/designsystem_layout.png" alt="레이아웃">
    </div>
    <p class="goal-eyebrow goal-eyebrow--color">1. 일관성 있는 사용자 경험</p>
    <div class="cv-lead">모든 화면에서 margin, padding, TitleArea, Container 같은 요소들이 동일한 규칙으로 배치되므로, <br>사용자는 익숙한 패턴 속에서 앱을 탐색할 수 있어요.</div>
    <p class="goal-eyebrow goal-eyebrow--color">2. 디자인·개발 생산성 향상</p>
    <div class="cv-lead">- 디자이너가 새로운 화면을 만들 때 기본 골격(Layout)을 재사용하므로 작업 속도가 향상되어요. <br> - 개발자는 동일한 컴포넌트 구조를 그대로 적용하면 되니 불필요한 UI 맞춤작업이 줄어들어요. 
        <br> - 불필요한 커뮤니케이션(“이 화면은 margin 몇 px로 할까요?”)이 줄어들어요.</div>
    <p class="goal-eyebrow goal-eyebrow--color">3. 유지보수 용이성</p>
    <div class="cv-lead">margin, status bar 높이, title area 규칙을 전역에서 정의하면, 추후 디자인 개편 시 한 곳만 수정해도 전체 화면에 반영할 수 있어요.<br> 
        (예: margin 16px → 20px로 바뀌어도 레이아웃 시스템만 업데이트하면 전체 앱이 자동 적용.)</div>
 </section>
 <section class="version-gray-section">
    <div class="content-wrap">
        <p class="goal-eyebrow" id="sec-version">버전 관리 원칙</p>
        <div class="cv-title">버전 관리를 위한 업그레이드 기준</div>
        <div class="cv-lead">제품 수, 팀 규모, 사업 단계 등에 따라 변화하므로 디자인시스템에 완성은 없다고 생각해요. <br> 시행착오를 반복하면서 목적을 달성하기 위해 개선을 반복하는 것이 디자인시스템의 본질이에요.</div>
        <p class="goal-eyebrow goal-eyebrow--size">소수점 세자리 수 단위 (0.0.1) 단위로 관리하고, 자릿수 별로 변경할 때의 기준은 다음과 같다.</p>
        <div class="cv-lead">가장 높은 단위 : 첫번째 자리 변경 기준</div>
        <div class="cv-card">
            <p class="cv-lead"><strong>개념적이고 전체적인 철학의 변화 :</strong> 브랜딩 방향성 변경으로 인한 리디자인 등으로 제품 전체를 관통하는 변화일 때</p>
        </div>
        <div class="cv-lead">중간 단위 : 두번째 자리 변경 기준</div>
        <div class="cv-card">
            <p class="cv-lead"><strong>많은 부분이 한꺼번에 생성되는 경우 : </strong>전체 로드맵상에서 계획적 버전 업데이트나 새 프로젝트가 제품에 반영되는 경우</p>
        </div>
        <div class="cv-lead">가장 작은 단위 : 세번째 자리 변경 기준</div>
        <div class="cv-card cv-card-margin">
            <p class="cv-lead"><strong>컴포넌트 변경 및 추가, 삭제 :</strong> 미세한 수정사항 부터 컴포넌트 추가, 삭제까지 상황에 따라 대응</p>
        </div>
        <p class="goal-eyebrow goal-eyebrow--color">1. 변경 내역의 추적 가능성과 히스토리 관리 용이</p>
        <div class="cv-lead">단순히 “디자인이 바뀌었다”가 아니라, 어떤 수준의 변화(대규모/부분/세부)인지를 명확히 구분할 수 있어 <br> 나중에 특정 시점의 디자인 상태를 복원하거나 참고해야 할 때 기록을 찾아볼 수 있어요. <br>
            디자인 시스템의 발전 과정을 되돌아볼 때, 철학 변화, 프로젝트 반영, 컴포넌트 수정이 언제 있었는지 쉽게 알 수 있어요.</div>
        <p class="goal-eyebrow goal-eyebrow--color">2. 팀 간 커뮤니케이션 효율성 증가</p>
        <div class="cv-lead">“이건 0.0.1 업데이트니까 세부 수정이야” 같은 식으로 팀원들이 버전 숫자만 보고도 변경 범위와 영향도를 직관적으로 알 수 있어요.</div>
        <p class="goal-eyebrow goal-eyebrow--color">3. 배포 안정성 강화</p>
        <div class="cv-lead">버전 원칙에 따라 변경 크기를 나누면, 작은 수정(0.0.1)과 큰 개편(1.0.0)을 구분할 수 있어 위험 관리가 쉬워져요. <br> 서비스에 즉시 반영해도 되는지, 아니면 QA·테스트를 반드시 거쳐야 하는지 판단 기준이 가능해요.</div>
        <p class="goal-eyebrow goal-eyebrow--color">4. 일관된 업데이트 프로세스</p>
        <div class="cv-lead">업데이트 기준이 없으면 “이건 새 컴포넌트니까 어떻게 버전을 올려야 하지?” 같은 논란이 생길 수 있어요.<br> 원칙을 정해두면 누구나 같은 기준으로 버전을 올리므로, 일관성 있는 기록 관리가 가능해요.</div>
    </div>
 </section>
 <section class="component-white-section">
    <p class="goal-eyebrow" id="sec-component">컴포넌트</p>
    <div class="cv-title cv-title--height">해당 컴포넌트의 사용, 디자인 가이드를 필요한 만큼만 적고 <br> 변형(Variation) 기준을 고려하며 컴포넌트를 만들었어요.</div>
    <div class="component-img">
        <img src="src/assets/image/designsystem_component.png" alt="컴포넌트">
    </div>
    <p class="goal-eyebrow" id="sec-result">결과</p>
    <div class="cv-title">스토리북이 나오면서 출시 전에 즉각적인 대응이 가능해졌어요.</div>
    <div class="stroybook-img">
        <img src="src/assets/image/designsystem_storybook.png" alt="스토리북">
    </div>
    <div class="cv-lead">굿덕에선 스토리북을 사용하고 있지않아 도입하자고 제안했어요. <br> 예를 들어 데이터 센터 그래프가 스토리북으로 나왔을 때, 막대 그래프가 6개 이상이면 어떻게 나오지? <br> 
     라는 궁금증이 생기면 그 즉시 스토리북에서 해보고, 디자인적으로 이상이 생기면 전달했어요. <br> 출시 후 수정이 아니라 출시 전 수정이 가능해졌어요. 또한 디자이너가 개발자의 언어를 이해하기 쉬워졌어요. <br>
     스토리북으로 간단한 조작이 가능해지면서 이럴때 이 언어를 쓰는구나 하는 이해가 조금은 가능해져요.</div>
    <div class="cv-title cv-title--margin">개발자와의 커뮤니케이션 감소</div>
    <div class="cv-lead">디자인 시스템을 만든 후 개발자분들과 커뮤니케이션하는 시간이 현저히 적어졌어요. <br> 디자인 시스템에 있는 컴포넌트대로 만드니 개발자는 그대로 개발하면되고, 디자인에 들어가는 소통이 줄어든 만큼 <br>
        기획적으로 변경사항이 있을 때, 로직이 바뀌었을 때 설명하는 시간에 할애할 수 있었어요.</div>
    <p class="goal-eyebrow goal-eyebrow--margin" id="sec-final">회고</p>
    <div class="cv-title">1차 디자인 시스템 구축 반성점을 2차에서 개선</div>
    <p class="cv-lead">전 회사에서 처음으로 디자인 시스템을 만들었을 때와 굿덕에서 두번째로 만들었을 때를 비교하여 반성점과 개선한 점을 정리했어요.</p>
    <div class="remember-img">
        <img src="src/assets/image/designsystem_remember.png" alt="회고">
    </div>
 </section>
 <footer class="footer-wrap">
  <div class="footer-left01">© 2025 Lee Ga Yun.</div>
  <div class="footer-right01">
   <a href="datadriven.html" class="next-link">Next Project →</a>
  </div>
</footer>
<footer class="footer">
  <div class="footer-inner">
    <div class="footer-left">
      <p><strong>gayun91101@gmail.com</strong></p>
      <p><strong>01089832923</strong></p>
      <p class="copy">© 2025 Lee Ga Yun.</p>
    </div>
    <div class="footer-right">
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="work.html">Work</a></li>
        <li><a href="article.html">Article</a></li>
        <li><a href="https://my.surfit.io/w/125142535" target="_blank">Resume</a></li>
      </ul>
    </div>
  </div>
</footer>
<script>
  const sections = document.querySelectorAll('[id^="sec-"]'); // 모든 섹션
  const navLinks = document.querySelectorAll('.toc__nav a');   // 사이드바 메뉴

  // 클릭 시 스크롤 이동 + 수동 active (기존처럼)
  navLinks.forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault();
      const targetId = link.getAttribute('href');
      const target = document.querySelector(targetId);
      const headerOffset = 100; // 위쪽 여백 (고정 헤더 높이에 맞게 조정)
      const elementPosition = target.getBoundingClientRect().top;
      const offsetPosition = window.scrollY + elementPosition - headerOffset;

      window.scrollTo({
        top: offsetPosition,
        behavior: 'smooth'
      });
    });
  });

  // Intersection Observer: 스크롤 위치에 따라 active 전환
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const id = entry.target.getAttribute('id');
      const activeLink = document.querySelector(`.toc__nav a[href="#${id}"]`);
      if (entry.isIntersecting) {
        navLinks.forEach(link => link.classList.remove('active'));
        activeLink?.classList.add('active');
      }
    });
  }, {
    threshold: 0.4  // 섹션이 40% 이상 보이면 active
  });

  sections.forEach(section => observer.observe(section));
</script>
<script>
/**
 * Scroll Reveal (Full JS)
 * - 제외(항상 고정): .gnb 계열, .toc(사이드바), .footer/.footer-wrap,
 *                    .summary-black-section (요소 자체만), .summary-title (자손 포함 전부)
 * - 포함: 위 제외 대상을 뺀 모든 요소. 특히 summary-black-section 내부 콘텐츠는 포함.
 * - 1회성 인터섹션 관찰로 자연스러운 페이드업 + 살짝 이동 + 블러 제거.
 */
(function () {
  // ===== 설정 =====
  const EXCLUDE_ANCESTOR = ['.gnb', '.toc', '.footer', '.footer-wrap'];
  const EXCLUDE_SELF_ONLY = ['.summary-black-section']; // 요소 자체만 제외, 자식은 포함
  const ALWAYS_EXCLUDE_TREE = ['.summary-title']; // 요소 + 모든 자손 제외

  // ===== 사전 정리: summary-title 트리에서 기존 마킹 제거(혹시 기존 스크립트 실행됐을 수도 있으므로) =====
  (function cleanupSummaryTitleTree() {
    const nodes = document.querySelectorAll(ALWAYS_EXCLUDE_TREE.join(', '));
    nodes.forEach(root => {
      root.classList.add('no-reveal');
      // 자손 모두 제외
      root.querySelectorAll('*').forEach(child => child.classList.add('no-reveal'));
    });
    document.querySelectorAll(
      ALWAYS_EXCLUDE_TREE.map(sel => `${sel}, ${sel} *`).join(', ')
    ).forEach(el => {
      el.classList.remove('reveal', 'is-visible');
      el.style.transitionDelay = '';
      el.removeAttribute('data-reveal-root');
      el.removeAttribute('data-reveal-root-marked');
      el.removeAttribute('data-reveal-prepared');
    });
  })();

  // ===== 도우미 =====
  const isElementVisibleByStyle = (el) => {
    const cs = window.getComputedStyle(el);
    if (cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0') return false;
    return true;
  };

  const isExcluded = (el) => {
    if (!(el instanceof HTMLElement)) return true; // 텍스트/코멘트 노드 등 제외

    // summary-title 내부(자손 포함) 전부 제외
    if (el.closest(ALWAYS_EXCLUDE_TREE.join(', '))) return true;

    // 자신이 "요소 자체만" 제외 목록에 해당하면 제외(단, 자손은 포함 규칙이므로 여기서는 matches만 체크)
    if (EXCLUDE_SELF_ONLY.some(sel => el.matches(sel))) return true;

    // gnb / toc / footer 계열 트리 내부면 제외
    if (EXCLUDE_ANCESTOR.some(sel => el.closest(sel))) return true;

    // 사용자 강제 제외
    if (el.classList.contains('no-reveal')) return true;

    return false;
  };

  // 섹션/카드 루트 감지(조금 더 부드럽게)
  const isRevealRoot = (el) => {
    return !!el.closest('section, article, .goal-card, .situation-card, .cv-card, .component-img, .impact-metrics, .mockups');
  };

  // ===== 대상 수집 =====
  const candidates = Array.from(document.body.querySelectorAll('*')).filter(el => {
    if (!isElementVisibleByStyle(el)) return false;
    if (isExcluded(el)) return false;
    return true;
  });

  // 초기 마킹(.reveal 부여)
  candidates.forEach(el => el.classList.add('reveal'));

  // ===== 지연(stagger) 처리 =====
  const groupIndexMap = new WeakMap();
  const nextStaggerForParent = (parent) => {
    const idx = groupIndexMap.get(parent) || 0;
    groupIndexMap.set(parent, idx + 1);
    const step = Math.min(idx, 7); // 최대 8단계
    return step * 60; // 60ms 간격
  };

  // ===== Intersection Observer =====
  const io = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (!entry.isIntersecting) return;

      const el = entry.target;

      // 1회성 준비(딜레이/루트 마커)
      if (!el.dataset.revealPrepared) {
        const parent = el.parentElement || document.body;
        el.style.transitionDelay = nextStaggerForParent(parent) + 'ms';

        if (isRevealRoot(el) && !el.dataset.revealRootMarked) {
          el.dataset.revealRoot = 'true';
          el.dataset.revealRootMarked = '1';
        }
        el.dataset.revealPrepared = '1';
      }

      // 표시
      el.classList.add('is-visible');
      io.unobserve(el);
    });
  }, {
    root: null,
    rootMargin: '0px 0px -10% 0px', // 하단 10% 여유
    threshold: 0.12
  });

  // 관찰 시작
  candidates.forEach(el => io.observe(el));

  // ===== 동적/지연 로드 이미지 대비 =====
  window.addEventListener('load', () => {
    document.querySelectorAll('img').forEach(img => {
      if (!img.complete) {
        img.addEventListener('load', () => {
          if (img.classList.contains('reveal') && !img.classList.contains('is-visible')) {
            io.observe(img); // 레이아웃 갱신 후 재관찰
          }
        });
      }
    });
  });

  // ===== 디버깅 플래그 =====
  window.__REVEAL_ACTIVE__ = true;
})();
</script>
</body>
</html>